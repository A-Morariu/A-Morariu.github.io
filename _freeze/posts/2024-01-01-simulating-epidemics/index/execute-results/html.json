{
  "hash": "1ed5ad022e8189619e87e838e37afef6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Simulating an epidemic\"\ndescription: \"We take a look at the popular (and simple) chain-binomial model for simulating an epidemic\"\nauthor:\n  - name: Alin Morariu\n    #orcid: 0000-0002-5300-3075\n    affiliation: Lancaster University\n    affiliation-url: https://www.lancaster.ac.uk/maths/\ndate: 01-01-2024\ncategories: [epidemics, simulation] # self-defined categories\n#image: preview-image.png\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\ncode-annotations: hover\nlightbox: auto\n---\n\n\n\n\nWhen I started my PhD two years ago, I had never looked at an epidemic model outside of an elementry differential equations course. Fast forward two years and one Covid-19 later, the bulk of my work is centred around epidemic models. More specifically, stochastic epidemic models. Differential equation models are simple and easy to use but are often too rigid since they don't reflect the randomness we see in the real world when it comes to epidemic models. \n\nThis post is going to be a tutorial for implementing/coding a chain binomial epidemic model in Python. This model is sometimes referred to as the Reed-Frost model and was initially used to model epidemic spread in the late 1920s (more details[^1]). \n\n## Reed-Frost model \nThe Reed-Frost model is a simple and intuitive mathematical model used to understand how infectious diseases spread through a population. This model helps us predict the number of people who will become infected over time, given some initial conditions.\n\n### Intuition \nImagine a group of people where some are initially infected with a disease, and others are susceptible but not yet infected. The Reed-Frost model works by dividing time into discrete steps[^2], such as days or weeks. At each time step, each susceptible person has a chance of getting infected based on their contact with infectious individuals.\n\nAt the beginning of the outbreak, the population is divided into two groups: susceptible (those who can get infected) and infectious (those who are currently infected). If we were to think of this as a graphical representation, it would be a 2 compartment model. \n\n\n\n```{mermaid}\nflowchart LR\n  A(Susceptible) --> B(Infected)\n```\n\n\n\n\nNow the question becomes how do individuals move between these states. The model uses a probability parameter to represent the likelihood that a susceptible person will get infected upon contact with an infectious person. This probability is often denoted as $p$. \n\nThe process unfolds over a series of discrete time steps. At each step, every susceptible individual has a chance to become infected if they come into contact with any infectious individuals (this is a very loose way to apply some mathematical structure to a very complex infection transmission mechanism).\n\nThe number of new infections at each time step depends on the number of susceptible and infectious individuals and the probability of transmission. The model assumes that once a person is infected, they remain infectious for only one time step.\n\n### Why this is a good starting\nThe Reed-Frost model is powerful because it captures the essential dynamics of disease transmission in a straightforward manner. It considers the key factors that drive an epidemic: the number of susceptible individuals, the number of infectious individuals, and the probability of transmission. By iterating this process over multiple time steps, the model can simulate the spread of an infection and help predict its potential impact on the population.\n\n## Python implementation \nFor this tutorial, I am going to try to use as few packages as possible so I'm going to restrict myself to *only* `numpy` and `pandas`. The rest of the code will be base Python. \n\nSo what do we have so far? We know we're going to be working with the Reed-Frost model which is a 2 state compartmental model. This is the class of the model and *not* a specific model. For that we need to add more structure. We need to know the size of population the disease is spreading through, the duration of each step in which events are happening (recall this is a discrete time model), and the last is going to be the transition rate or epidemic dynamics (how the disease is transmitted). The assumptions are as follows: \n1. 100 epidemic units[^3] with 99 susceptibles and 1 infected units. This is represented as a vector $[S_0, I_0] = [99,1]$ (the subscript $i$ is the time period).\n2. Time period is going to be daily so we set the time delta $\\triangle d = 1$. \n3. Epidemic dynamics will be a density based transmission where we 'count' the number of pairwise interactions between infectious units and susceptibles and divide by the population size. This means that the probabilty of an infection happening has a rate of $\\lambda_i= \\beta \\frac{S_i I_i}{S_i + I_i}$ which translates into a probability of $p_i = \\exp\\{- \\lambda_i * \\triangle d \\}$[^4].\n\n::: {#3eb87f7c .cell execution_count=1}\n``` {.python .cell-code}\n# load packages \nimport numpy as np\nimport pandas as pd \n\nimport matplotlib.pyplot as plt\nimport seaborn as sns \n\nsns.set()\n```\n:::\n\n\n::: {#087f2d91 .cell execution_count=2}\n``` {.python .cell-code}\n# initial values\ntime_delta = 1.                 # 1 day \ninitial_pop = [99.,1.]          # population vector \nparameters0 = 0.01              # daily transmission parameter \n```\n:::\n\n\nWith the constants and initial conditions set, its time to move to the main bit of the code which performs the simulation. The function below called `SI_iteration` takes 3 parameter values: \n1. `parameters` - this is a vector of model parameters. For now, this is a 1D vector holding the value for $\\beta$. \n2. `state` - this is a 2D vector containing the counts for each of the states.\n3. `time_delta` - the size (in days) of the discrete time step \n\n::: {#4cd1a5f8 .cell execution_count=3}\n``` {.python .cell-code}\ndef SI_iteration(parameters, state, time_delta):\n  beta = parameters\n  num_susceptibles, num_infected = state\n  \n  # Step 1: compute transition rates \n  SI_rate = beta*(num_susceptibles * num_infected)/(num_susceptibles + num_infected) # <1>\n\n  # Step 2: convert event rates to probabilities \n  i_rate = 1 - np.exp(- SI_rate * time_delta) # <2>\n\n  # Step 3: simulate number of new infections \n  num_new_infections = np.random.binomial(num_susceptibles, i_rate) # <3>\n\n  # Step 4; state update\n  return [num_susceptibles - num_new_infections, num_infected + num_new_infections]\n```\n:::\n\n\n1. Compute the transition rate\n2. Turn the transition rate into a probability of new infections \n3. Sample the number of new infections \n\nNow for using our new function. Taking the initial values for each of the function arguments and plugging them in, we can see that the outcome of a single iteration in our epidemic. \n\n::: {#c4135ea2 .cell execution_count=4}\n``` {.python .cell-code}\n# single iteration/forward step\nnp.random.seed(20240701)                                  # <1>\nnew_state = SI_iteration(parameters0, initial_pop, time_delta)\n\nprint(f'New state: {new_state}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNew state: [98.0, 2.0]\n```\n:::\n:::\n\n\n1. Set the seed for reproducible value. \n\n### Simulate a path\nWe can extend the single iteration to sample a full path of the epidemic by calling our function over and over again while changing the state. This is not the most efficient way of performing a simulation but it is easy to understand. I will write another tutorial about doing this efficiently later on... promise. \n\n::: {#9e9afac4 .cell execution_count=5}\n``` {.python .cell-code}\n# simulate full path\ndef simulate(initial_state, num_steps):\n    # counters\n    ii = 0\n    S = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n\n    # unpack the state\n    S[0], I[0] = initial_state\n    state = initial_state\n\n    while ii < num_steps:\n        state = SI_iteration(parameters0, state, time_delta)\n\n        S[ii], I[ii] = state\n\n        ii += 1\n\n    return {'Time': np.cumsum(np.repeat(time_delta, num_steps)),\n            'Susceptible': S,\n            'Infected': I}\n```\n:::\n\n\nLets plot the simulation! \n\n::: {#cb357883 .cell execution_count=6}\n``` {.python .cell-code}\nsample_epi = simulate(initial_pop, 100)\n\npd.DataFrame(sample_epi).head(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Time</th>\n      <th>Susceptible</th>\n      <th>Infected</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.0</td>\n      <td>99.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2.0</td>\n      <td>97.0</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3.0</td>\n      <td>94.0</td>\n      <td>6.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.0</td>\n      <td>86.0</td>\n      <td>14.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>74.0</td>\n      <td>26.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>6.0</td>\n      <td>56.0</td>\n      <td>44.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>7.0</td>\n      <td>41.0</td>\n      <td>59.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>8.0</td>\n      <td>35.0</td>\n      <td>65.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>9.0</td>\n      <td>29.0</td>\n      <td>71.0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>10.0</td>\n      <td>21.0</td>\n      <td>79.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#fig-plots .cell execution_count=7}\n``` {.python .cell-code}\nplt.figure(figsize=(12, 7))\n\nS_line = plt.plot(\"Time\",\"Susceptible\", data=sample_epi, color=\"b\", linewidth=2)\nI_line = plt.plot(\"Time\",\"Infected\", data=sample_epi, color=\"r\", linewidth=2)\n\nplt.xlabel(\"Days\",fontweight=\"bold\")\nplt.ylabel(\"Count\",fontweight=\"bold\")\n\nlegend = plt.legend(title=\"Population\",loc=5,bbox_to_anchor=(1.2,0.5))\nframe = legend.get_frame()\nframe.set_facecolor(\"white\")\nframe.set_linewidth(0)\n\n# Add labels and title\nplt.xlabel('Days', fontweight=\"bold\")  # Add x-axis label with font styling\nplt.ylabel('Count', fontweight=\"bold\")  # Add y-axis label with font styling\nplt.title('Singe path simulation', fontsize=16)  # Add plot title with font size\n```\n\n::: {#fig-plots-1 .cell-output .cell-output-display execution_count=7}\n```\nText(0.5, 1.0, 'Singe path simulation')\n```\n\nFull path of an epidemic. Simulation is done by calling     the single iteration function repeatedly\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/fig-plots-output-2.png){#fig-plots-2 width=1140 height=607}\n:::\n:::\n\n\n### Conclusion\nEpidemic models are cool! \n\n\n[^1]: [Resource here](https://deepblue.lib.umich.edu/bitstream/handle/2027.42/26512/0000050.pdf?sequence=1&isAllowed=y&fbclid=IwAR38zIDg_-vvXCMWHDoy-6rLXAluIa5ggiCmsalzh1IUBFaVxACS6KF3Cms)\n[^2]: I usually work with continuous time models which pose their own challenges. More on this will come in later posts\n[^3]: An epidemic unit can be anything that we can classify as susceptible or infected. These models are used for humans and animals so its easier to generalize the concept of an epidemic unit. The units can even be aggregated to represent households or farms. It gives us a more flexibility to adapt the scope of the model. \n[^4]: Future post on the interpretable mathematics of epidemic models\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}