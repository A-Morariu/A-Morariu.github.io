{
  "hash": "ca50b4c0e8a34865e8bc9e13fbf09abc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Simulating an epidemic\"\ndescription: \"We take a look at the popular (and simple) chain-binomial model for simulating an epidemic\"\nauthor:\n  - name: Alin Morariu\n    #orcid: 0000-0002-5300-3075\n    affiliation: Lancaster University\n    affiliation-url: https://www.lancaster.ac.uk/maths/\ndate: 07-01-2024          # MM-DD-YYYY\ncategories: [epidemics, simulation] # self-defined categories\nimage: DSC_6355.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\ncode-annotations: hover\nlightbox: auto\n---\n\n\nWhen I started my PhD two years ago, I had never looked at an epidemic model outside of an elementry differential equations course. Fast forward two years, and one Covid-19 later, the bulk of my work is centred around epidemic models. More specifically, *stochastic* epidemic models. Differential equation models are simple and easy to use but are often too rigid since they don't reflect the randomness we see in the real world when it comes to the spread of disease.\n\nThis post is going to be a tutorial that I wish I had at the start of my epidemic modelling journey. The aim is to implement/code a chain binomial epidemic model in Python. This model is sometimes referred to as the Reed-Frost model and was initially used to model epidemic spread in the late 1920s (more details[^1]). It is one of the simplest epidemic models as it only focuses on the infection process so take this as the base case. Future posts will dive deeper into the mathematics and how to expand on this model to make it more realistic. \n\n## Reed-Frost model \nThe Reed-Frost model helps us predict the number of people who will become infected over time, given some initial conditions. \n\n### Intuition \nImagine a group of people where some are initially infected with a disease, and others are susceptible but not yet infected. The Reed-Frost model works by dividing time into discrete steps[^2], such as days or weeks. At each time step, each susceptible person has a chance of getting infected based on their contact with infectious individuals.\n\nAt the beginning of the outbreak, the population is divided into two groups: susceptible (those who can get infected) and infectious (those who are currently infected). If we were to think of this as a graphical representation, it would be a 2 compartment model. \n\n```{mermaid}\nflowchart LR\n  A(Susceptible) --> B(Infected)\n```\n\n\nNow the question becomes how do individuals move between these states. The model uses a probability parameter to represent the likelihood that a susceptible person will get infected upon contact with an infectious person. This probability is often denoted as $p$. \n\nThe process unfolds over a series of discrete time steps. At each step, every susceptible individual has a chance to become infected if they come into contact with any infectious individuals (this is a very loose way to apply some mathematical structure to a very complex infection transmission mechanism).\n\nThe number of new infections at each time step depends on the number of susceptible and infectious individuals and the probability of transmission. The model assumes that once a person is infected, they remain infectious for only one time step.\n\n### Why this is a good starting\nThe Reed-Frost model is powerful because it captures the essential dynamics of disease transmission in a straightforward manner. It considers the key factors that drive an epidemic: the number of susceptible individuals, the number of infectious individuals, and the probability of transmission. By iterating this process over multiple time steps, the model can simulate the spread of an infection and help predict its potential impact on the population.\n\n## Python implementation \nFor this tutorial, I am going to try to use as few packages as possible so I'm going to restrict myself to *only* `numpy` and `pandas`. The rest of the code will be base Python. \n\n::: {#57f3850a .cell execution_count=1}\n``` {.python .cell-code}\n# load packages \nimport numpy as np\nimport pandas as pd \n\nimport matplotlib.pyplot as plt\nimport seaborn as sns \n\nsns.set()\n```\n:::\n\n\nLet's take stock of what we know at this point. The Reed-Frost model which is a 2-state compartmental model. \n\n:::{.callout-important}\nThis is a class of models and *not* a specific model.\n:::\n\nTo specify a model we need to add more structure. We want to know the size of population the disease is spreading through, the duration of each step in which events are happening (recall this is a discrete time model), and the last is going to be the transition rate or epidemic dynamics (how the disease is transmitted). The assumptions are as follows: \n\n1. 100 epidemic units[^3] with 99 susceptibles and 1 infected units. This is represented as a vector $[S_0, I_0] = [99,1]$ (the subscript $i$ is the time period).\n2. Time period is going to be daily so we set the time delta $\\triangle d = 1$. \n3. Epidemic dynamics will be a density based transmission where we 'count' the number of pairwise interactions between infectious units and susceptibles and divide by the population size. This means that the probabilty of an infection happening has a rate of $\\lambda_i= \\beta \\frac{S_i I_i}{S_i + I_i}$ which translates into a probability of $p_i = \\exp\\{- \\lambda_i * \\triangle d \\}$[^4].\n\n::: {#3744fa8c .cell execution_count=2}\n``` {.python .cell-code}\n# initial values\ntime_delta = 1.                 # 1 day \ninitial_pop = [99.,1.]          # population vector \nparameters0 = 0.01              # daily transmission parameter \n```\n:::\n\n\nWith the constants and initial conditions set, its time to move to the main bit of the code which performs the simulation. \n\n:::{.callout-tip}\nI've been using the term implementing a model and this doesn't really have a set definition. In this case, implementation is done when you can simulate a correct trajectory of the epidemic but in other settings it may mean fitting a model to data, validating, predicting, etc. The scope of an implementation changes with the nature of the problem and is context specific. Its all jargon here. \n:::\n\nThe function below called `SI_iteration` takes 3 parameter values: \n1. `parameters` - this is a vector of model parameters. For now, this is a 1D vector holding the value for $\\beta$. \n2. `state` - this is a 2D vector containing the counts for each of the states.\n3. `time_delta` - the size (in days) of the discrete time step \n\n::: {#80150d9d .cell execution_count=3}\n``` {.python .cell-code}\ndef SI_iteration(parameters, state, time_delta):\n  beta = parameters\n  num_susceptibles, num_infected = state\n  \n  # Step 1: compute transition rates \n  SI_rate = beta*(num_susceptibles * num_infected)/(num_susceptibles + num_infected) # <1>\n\n  # Step 2: convert event rates to probabilities \n  i_rate = 1 - np.exp(- SI_rate * time_delta) # <2>\n\n  # Step 3: simulate number of new infections \n  num_new_infections = np.random.binomial(num_susceptibles, i_rate) # <3>\n\n  # Step 4; state update\n  return [num_susceptibles - num_new_infections, num_infected + num_new_infections]\n```\n:::\n\n\n1. Compute the transition rate\n2. Turn the transition rate into a probability of new infections \n3. Sample the number of new infections \n\nI'm going to ignore the mathematics of Step 2 in chunk above *for now* since that will be its own post down the line. The gory details can be found in the paper I mentioned earlier for those curious. Now for using our new function! Taking the initial values for each of the arguments and plugging them in, we can get the outcome of a single iteration or single step of our epidemic process. This is not a complete path! \n\n::: {#7283e46d .cell execution_count=4}\n``` {.python .cell-code}\n# single iteration/forward step\nnp.random.seed(20240701)                                  # <1>\nnew_state = SI_iteration(parameters0, initial_pop, time_delta)\n\nprint(f'New state: {new_state}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNew state: [98.0, 2.0]\n```\n:::\n:::\n\n\n1. Set the seed for reproducible value. \n\n### Simulate a path\nWe can extend the single iteration to sample a full path of the epidemic by calling our function over and over again. This is not the most efficient way of performing a simulation but it is easy to understand so it'll do for now. \n\n::: {#624b87ea .cell execution_count=5}\n``` {.python .cell-code}\n# simulate full path\ndef simulate(initial_state, num_steps):\n    # counters\n    ii = 0\n    S = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n\n    # unpack the state\n    S[0], I[0] = initial_state\n    state = initial_state\n\n    while ii < num_steps:\n      # single iteration to update the state\n      state = SI_iteration(parameters0, state, time_delta)\n      # record the outcome\n      S[ii], I[ii] = state\n\n      ii += 1\n\n    return {'Time': np.cumsum(np.repeat(time_delta, num_steps)),\n            'Susceptible': S,\n            'Infected': I}\n```\n:::\n\n\nAnd run a simulation of 100 steps (note that some of the steps might be non-events since every unit has progressed through the epidemic). There are nice ways of stopping simulations early by using a clever stop condition within the while loop.\n\n::: {#cell-epi_dataset .cell execution_count=6}\n``` {.python .cell-code}\nsample_epi = simulate(initial_pop, 100)\n\npd.DataFrame(sample_epi).head(10)\n```\n\n::: {#epi_dataset .cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Time</th>\n      <th>Susceptible</th>\n      <th>Infected</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.0</td>\n      <td>99.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2.0</td>\n      <td>97.0</td>\n      <td>3.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3.0</td>\n      <td>94.0</td>\n      <td>6.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4.0</td>\n      <td>86.0</td>\n      <td>14.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5.0</td>\n      <td>74.0</td>\n      <td>26.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>6.0</td>\n      <td>56.0</td>\n      <td>44.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>7.0</td>\n      <td>41.0</td>\n      <td>59.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>8.0</td>\n      <td>35.0</td>\n      <td>65.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>9.0</td>\n      <td>29.0</td>\n      <td>71.0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>10.0</td>\n      <td>21.0</td>\n      <td>79.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLets plot the simulation! \n\n::: {#cell-simulated_path .cell width='80%' execution_count=7}\n``` {.python .cell-code}\nplt.figure(figsize=(12, 7))\n\nS_line = plt.plot(\"Time\",\"Susceptible\", data=sample_epi, color=\"b\", linewidth=2)\nI_line = plt.plot(\"Time\",\"Infected\", data=sample_epi, color=\"r\", linewidth=2)\n\nplt.xlabel(\"Days\",fontweight=\"bold\")\nplt.ylabel(\"Count\",fontweight=\"bold\")\n\nlegend = plt.legend(title=\"Population\",loc=5,bbox_to_anchor=(1.2,0.5))\nframe = legend.get_frame()\nframe.set_facecolor(\"white\")\nframe.set_linewidth(0)\n\n# Add labels and title\nplt.xlabel('Days', fontweight=\"bold\")  # Add x-axis label with font styling\nplt.ylabel('Count', fontweight=\"bold\")  # Add y-axis label with font styling\nplt.title('Single path simulation', fontsize=16)  # Add plot title with font size\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Full path of an epidemic. Simulation is done by calling     the single iteration function repeatedly](index_files/figure-html/simulated_path-output-1.png){#simulated_path width=1140 height=607}\n:::\n:::\n\n\n### Conclusion\nIn this tutorial, I showed one way to implement a chain binomial epidemic model. This basic model is a great starting point for building more complex and realistic models. The function `SI_iteration` uses a simplified version of the [Gillespie algorithm](https://en.wikipedia.org/wiki/Gillespie_algorithm) which is the standard algorithm for simulating stochastic trajectories for these types of systems. I'd also recommend checking out [this blog](https://lewiscoleblog.com/gillespie-algorithm) post by Lewis Cole for an in depth look at the algorithm.\n\n### Next steps\nAs far as using epidemic models in the real world goes, simulation is only one half of the coin. The other side has to do with fitting these models. If the problem was reversed and we had observed an epidemic process, recorded the data and created a data set that looks something like @epi_dataset we could then try to find the value of `parameters` which generated that data. This can be done in a variety of ways such as maximum likelihood estimation or Bayesian inference. If this type of problem interests you, I'd highly recommend checking out the [IDDinf 2024](https://gem-epidemics.gitlab.io/iddinf/) inference course. This is a course I will be co-teaching with some incredible people in September 2024 and will go over everything you need to know to fit epidemic models with Bayesian inference. \n\n### Thanks for reading\nIn my spare time, I like to take photos so I'm going to add one photo I like at the end of each post as a thank you :) \n![Ile du Frioul, Marseille, France, 2024](DSC_6355.jpg){.lightbox}\n\n[^1]: [Resource here](https://deepblue.lib.umich.edu/bitstream/handle/2027.42/26512/0000050.pdf?sequence=1&isAllowed=y&fbclid=IwAR38zIDg_-vvXCMWHDoy-6rLXAluIa5ggiCmsalzh1IUBFaVxACS6KF3Cms)\n[^2]: I usually work with continuous time models which pose their own challenges. More on this will come in later posts\n[^3]: An epidemic unit can be anything that we can classify as susceptible or infected. These models are used for humans and animals so its easier to generalize the concept of an epidemic unit. The units can even be aggregated to represent households or farms. It gives us a more flexibility to adapt the scope of the model. \n[^4]: Future post on the interpretable mathematics of epidemic models\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}